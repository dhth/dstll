// ==== OTHER ====

// Trait
trait Drawable {
    fn draw(&self); // should not match a function definition
}

// Trait with generics
trait Resizable<T> {
    fn resize(&mut self, value: T); // should not match a function definition
}

// Type alias
type TableAlias = Table;

// Constant
const MAX_SIZE: usize = 100;

// Static variable
static mut COUNTER: i32 = 0;

// Macro
macro_rules! create_function {
    ($name:ident) => {
        fn $name() {
            println!("You called {:?}()", stringify!($name));
        }
    };
}

// Using the macro to create a function
create_function!(foo);

// === STRUCTS ===

struct Empty;
struct Unit;
struct Color(i32, i32, i32);

struct Table {
    field1: i32,
    field2: String,
}

struct GenericStruct<T> {
    field: T,
}

#[derive(Debug)]
pub struct Point {
    pub x: i32,
    y: i32,
}

pub(crate) struct Point {
    x: i32,
    y: i32,
}

pub(super) struct Point {
    x: i32,
    y: i32,
}

pub(in crate::some_module) struct Point {
    x: i32,
    y: i32,
}

// ==== ENUMS ====

enum Direction {
    North,
    South,
    East,
    West,
}

pub enum Option<T> {
    Some(T),
    None,
}

pub(crate) enum Option<T> {
    Some(T),
    None,
}

pub(super) enum Option<T> {
    Some(T),
    None,
}

pub(in crate::some_module) enum Option<T> {
    Some(T),
    None,
}

// Enum with Named Fields
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor { r: u8, g: u8, b: u8 },
}

// Enum with Tuple-like Variants
enum Result<T, E> {
    Ok(T),
    Err(E),
}

// Enum with Generics
enum GenericEnum<T> {
    Value(T),
    Nothing,
}

// Enum with Lifetimes
enum RefEnum<'a, T> {
    Borrowed(&'a T),
    Owned(T),
}

// ==== FUNCS ====

// A basic function
fn function_name() {
    println!("This is a basic function.");
}

// Function with generics
fn generic_function<T>(value: T) -> T {
    value
}

#[inline]
pub fn public_function() -> i32 {
    42
}

pub(crate) fn crate_function() -> i32 {
    42
}

pub(super) fn parent_function() -> i32 {
    42
}

pub(in crate::some_module) fn specific_module_function() -> i32 {
    42
}

// Implementation block for the Table struct
impl Table {
    // Associated function
    fn new(field1: i32, field2: String) -> Self {
        Table { field1, field2 }
    }

    // Method with explicit lifetimes
    fn apply_to<'a>(&'a self, data: &'a mut Table) -> &'a mut Table {
        data.field1 += self.field1;
        data.field2.push_str(&self.field2);
        data
    }

    // Method
    fn update(&mut self, field1: i32) {
        self.field1 = field1;
    }
}

// Implementation of a trait for a struct
impl Drawable for Table {
    fn draw(&self) {
        println!(
            "Drawing Table with field1: {} and field2: {}",
            self.field1, self.field2
        );
    }
}

// Implementation of a trait with generics for a struct
impl<T> Resizable<T> for GenericStruct<T> {
    fn resize(&mut self, value: T) {
        self.field = value;
    }
}

// Implementation block for a struct with generics
impl<T> GenericStruct<T> {
    // Associated function
    fn new(field: T) -> Self {
        GenericStruct { field }
    }

    // Method
    fn get_field(&self) -> &T {
        &self.field
    }
}
